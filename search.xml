<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树的学习及使用</title>
      <link href="/2023/11/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>在二叉树的学习中，常见的种类包括：</p><ol><li><p><strong>满二叉树：</strong></p><ul><li>每个节点都有零个或两个子节点，且所有叶子节点都在同一层。</li></ul></li><li><p><strong>完全二叉树：</strong></p><ul><li>除了最后一层外，每一层都被完全填充，且所有节点都保持向左对齐。</li></ul></li><li><p><strong>二叉搜索树：</strong></p><ul><li>每个节点的左子树只包含小于当前节点的值，右子树只包含大于当前节点的值。</li></ul></li><li><p><strong>平衡二叉搜索树（AVL）：</strong></p><ul><li>一种特殊的二叉搜索树，保持左右子树的高度差不超过1。</li></ul></li></ol><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>二叉树的存储方式包括：</p><ol><li><p><strong>链式存储：</strong></p><ul><li>通过节点之间的引用关系连接。</li></ul></li><li><p><strong>顺序存储（数组）：</strong></p><ul><li>通过数组的索引关系表示节点之间的位置。</li></ul></li></ol><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>对二叉树进行遍历有深度优先遍历和广度优先遍历两种方式：</p><ol><li><p><strong>深度优先遍历：</strong></p><ul><li>前序遍历（根、左、右）、中序遍历（左、根、右）、后序遍历（左、右、根）。这里前中后，其实指的就是根节点的遍历顺序<br><img src="/images/TraverseTree.png" alt="二叉树示例图片"></li></ul></li><li><p><strong>广度优先遍历：</strong></p><ul><li>层次遍历，逐层从左到右遍历。</li></ul></li></ol><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><pre><code>public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode() &#123;&#125;    TreeNode(int val) &#123; this.val = val; &#125;    TreeNode(int val, TreeNode left, TreeNode right) &#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;</code></pre><h2 id="算法实现：前序遍历"><a href="#算法实现：前序遍历" class="headerlink" title="算法实现：前序遍历"></a>算法实现：前序遍历</h2><pre><code>class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();        preorder(root, result);        return result;    &#125;    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;        if (root == null) &#123;            return;        &#125;        result.add(root.val);        preorder(root.left, result);        preorder(root.right, result);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Data Structures </category>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="/2023/11/22/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2023/11/22/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>寻找重复数</title>
      <link href="/2023/11/21/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
      <url>/2023/11/21/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三数之和</title>
      <link href="/2023/11/20/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/11/20/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手机抓包工具及原理</title>
      <link href="/2023/11/19/%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/"/>
      <url>/2023/11/19/%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/hacker.png" alt="示例图片"></p><h1 id="手机抓包工具及原理"><a href="#手机抓包工具及原理" class="headerlink" title="手机抓包工具及原理"></a>手机抓包工具及原理</h1><p>在移动应用开发中，抓包是一种常见的调试和分析网络请求的手段。以下是一些常用的抓包工具及简要介绍：</p><ol><li><p><strong>VMOS Pro:</strong></p><ul><li>虚拟机应用，用于在Android设备上创建虚拟环境。</li></ul></li><li><p><strong>HttpCanary:</strong></p><ul><li>抓包工具，用于监视和分析网络请求，支持HTTPS。</li></ul></li><li><p><strong>JustTrustMe:</strong></p><ul><li>Xposed框架模块，用于绕过SSL证书验证，方便抓取HTTPS请求。</li></ul></li><li><p><strong>JustMePlus &amp; JustMeAlready:</strong></p><ul><li>应用或模块，可能是一些变种工具，具体功能需要查阅相关文档。</li></ul></li><li><p><strong>MT管理工具:</strong></p><ul><li>待具体说明，可能是一款管理工具。</li></ul></li></ol><h2 id="抓包原理"><a href="#抓包原理" class="headerlink" title="抓包原理"></a>抓包原理</h2><ul><li><p><strong>截取C端到S端的数据：</strong></p><ul><li>通过在设备和服务器之间插入代理，抓包工具截获客户端（C端）到服务器（S端）的数据。</li></ul></li><li><p><strong>SSL处理：</strong></p><ul><li>由于涉及到SSL等加密协议，一些抓包工具可能需要绕过证书验证，以便能够查看加密的HTTPS请求。</li></ul></li></ul><p>详细原理待补充。</p><h2 id="过程遇到的问题"><a href="#过程遇到的问题" class="headerlink" title="过程遇到的问题"></a>过程遇到的问题</h2><p>在抓包过程中，可能会遇到一些问题，例如：</p><ul><li><p><strong>手机根目录与内部存储：</strong></p><ul><li>需要理解手机根目录和内部存储的具体含义，以便更好地操作文件和路径。</li></ul></li><li><p><strong>手机未Root导致中止：</strong></p><ul><li>由于手机未Root，可能会受到一些限制。在没有Root权限的情况下，需要使用虚拟机等方式继续抓包的探索。</li></ul></li></ul><p>记录这些问题有助于日后更好地解决类似挑战。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="CSDN%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5">安卓端小黄鸟抓包保姆级教程（附带全套工具，完美解决无网络和ROOT问题）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mobile Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包工具 </tag>
            
            <tag> 安卓 </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针的学习及使用</title>
      <link href="/2023/11/18/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/18/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Sky.png" alt="示例图片"></p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>双指针法，又称为快慢指针法，通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。这种方法在数组和链表的操作中非常常见，很多考察数组、链表、字符串等操作的面试题都使用双指针法。</p><p>双指针法常见的应用场景包括但不限于数组的查找、链表的反转、判环等问题。</p><h2 id="数组中的双指针"><a href="#数组中的双指针" class="headerlink" title="数组中的双指针"></a>数组中的双指针</h2><p>在数组中，常见的双指针应用包括：</p><ol><li><strong>两数之和：</strong> 使用左右双指针，从数组的两端向中间移动，寻找两数之和等于目标值的元素。</li><li><strong>三数之和：</strong> 使用三个指针，固定一个指针，另外两个指针分别从两端向中间移动，寻找三数之和等于目标值的元素组合。</li><li><strong>反转数组：</strong> 使用双指针，一个指向数组头部，另一个指向数组尾部，交换两个指针所指的元素，然后移动指针直至它们相遇。</li><li><strong>移动零：</strong> 使用双指针，一个指向当前非零元素的位置，另一个遍历数组，将非零元素移动到第一个指针的位置。</li></ol><h2 id="链表中的双指针"><a href="#链表中的双指针" class="headerlink" title="链表中的双指针"></a>链表中的双指针</h2><p>在链表中，常见的双指针应用包括：</p><ol><li><strong>判环：</strong> 使用快慢指针，快指针每次移动两步，慢指针每次移动一步，如果存在环，则两指针最终会相遇。</li><li><strong>链表中倒数第 k 个节点：</strong> 使用双指针，一个指针先移动 k 步，然后两个指针同时向后移动，当第一个指针到达链表尾部时，第二个指针指向倒数第 k 个节点。</li><li><strong>链表的反转：</strong> 使用三个指针，分别指向当前节点、前一个节点和后一个节点，逐个反转链表的节点。</li><li><strong>链表的合并：</strong> 使用两个指针分别指向两个有序链表的头部，比较节点大小，逐个合并两个链表。</li></ol><h1 id="LeetCode-11-盛最多水的容器"><a href="#LeetCode-11-盛最多水的容器" class="headerlink" title="LeetCode 11. 盛最多水的容器"></a>LeetCode 11. <a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-100-liked">盛最多水的容器</a></h1><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai)。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><strong>示例 :</strong><br>    输入: [1,8,6,2,5,4,8,3,7]<br>    输出: 49</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h2><pre><code>class Solution &#123;    public int maxArea(int[] height) &#123;        int res = 0;        int i = 0;        int j = height.length - 1;        while (i &lt; j) &#123;            int area = (j - i) * Math.min(height[i], height[j]);            res = Math.max(res, area);            if (height[i] &lt; height[j]) &#123;                i++;            &#125; else &#123;                j--;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h1 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode 27. 移除元素"></a>LeetCode 27. <a href="https://leetcode.cn/problems/remove-element/submissions/483008664/">移除元素</a></h1><p>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，必须使用 O(1) 额外空间并原地修改输入数组。</p><p><strong>示例 :</strong><br>    输入: nums &#x3D; [3,2,2,3], val &#x3D; 3<br>    输出: 新长度 2, nums &#x3D; [2,2]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解:"></a>题解:</h2><pre><code>class Solution &#123;    public int removeElement(int[] nums, int val) &#123;        // 快慢指针        int slowIndex = 0;        for (int fastIndex = 0; fastIndex &lt; nums.length; fastIndex++) &#123;            if (nums[fastIndex] != val) &#123;                nums[slowIndex] = nums[fastIndex];                slowIndex++;            &#125;        &#125;        return slowIndex;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
          <category> Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表的学习及使用</title>
      <link href="/2023/11/17/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/17/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/snow.png" alt="示例图片"></p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表是一種常見的數據結構，用於快速查找、插入和刪除。在判斷一個元素是否在集合中出現時，可以考慮使用哈希表。以下是一些常見的哈希結構：</p><h2 id="1-數組"><a href="#1-數組" class="headerlink" title="1. 數組"></a>1. 數組</h2><p>當鍵是整數或具有範圍的整數時，可以使用數組。例如，數組可用於實現計數排序，統計元素出現的次數。當需要直接通過索引或位置訪問元素時，數組是一個很好的選擇。</p><h2 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h2><p>當只需要存儲不重復的元素，並且不需要與每個元素關聯其他信息時，可以使用 Set。Set 提供了 O(1) 時間復雜度的查找和插入操作，用於判斷元素是否存在。</p><h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h2><p>當需要將鍵映射到值時，或者需要關聯每個鍵（或一組鍵）與一些信息時，可以使用 Map。在一些問題中，例如統計元素的頻率，將元素分組等，Map 是一個常見的選擇。如果需要在 O(1) 時間內查找、插入和刪除鍵值對，HashMap 是一個很好的選擇。如果需要按照鍵的順序（升序或降序）來迭代訪問元素，可以使用 TreeMap。</p><h1 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h1><p>hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize，这意味着避免不了会有几个数据同时映射到哈希表 同一个索引下标的位置，称为哈希碰撞。</p><h2 id="1-拉链法"><a href="#1-拉链法" class="headerlink" title="1.拉链法"></a>1.拉链法</h2><p>这种方案由数组和链表两种数据结构组成。如果发生了元素重复，就让冲突的位置变为一个链表。</p><h2 id="2-线性探测法"><a href="#2-线性探测法" class="headerlink" title="2.线性探测法"></a>2.线性探测法</h2><p>当经过哈希函数计算得到的值发生冲突后，将冲突元素放在旁边空闲位置。</p><h1 id="LeetCode-242-有效的字母異位詞"><a href="#LeetCode-242-有效的字母異位詞" class="headerlink" title="LeetCode 242. 有效的字母異位詞"></a>LeetCode 242. <a href="https://leetcode.cn/problems/valid-anagram/">有效的字母異位詞</a></h1><p>給定兩個字符串 s 和 t，編寫一個函數來判斷 t 是否是 s 的字母異位詞。</p><p><strong>示例 :</strong></p><pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false</code></pre><h2 id="题解（數組）"><a href="#题解（數組）" class="headerlink" title="题解（數組）:"></a>题解（數組）:</h2><p>定义一个数组叫做record用来上记录字符串s里字符出现的次数。需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</p><pre><code>class Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();        for (String str : strs) &#123;            int[] counts = new int[26];            int length = str.length();            for (int i = 0; i &lt; length; i++) &#123;                counts[str.charAt(i) - &#39;a&#39;]++;            &#125;            // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键            StringBuffer sb = new StringBuffer();            for (int i = 0; i &lt; 26; i++) &#123;                if (counts[i] != 0) &#123;                    sb.append((char) (&#39;a&#39; + i));                    sb.append(counts[i]);                &#125;            &#125;            String key = sb.toString();            List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());            list.add(str);            map.put(key, list);        &#125;        return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());    &#125;&#125;</code></pre><h1 id="LeetCode-49-字母异位词分组"><a href="#LeetCode-49-字母异位词分组" class="headerlink" title="LeetCode 49. 字母异位词分组"></a>LeetCode 49. <a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">字母异位词分组</a></h1><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指的是由相同的字符按照不同的顺序组成的单词。</p><p><strong>示例 :</strong></p><pre><code>输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;bat&quot;]]</code></pre><h2 id="题解（map）"><a href="#题解（map）" class="headerlink" title="题解（map）:"></a>题解（map）:</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
          <category> Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web 學習路線</title>
      <link href="/2023/11/16/Java%20Web%20%E5%AD%B8%E7%BF%92%E8%B7%AF%E7%B7%9A/"/>
      <url>/2023/11/16/Java%20Web%20%E5%AD%B8%E7%BF%92%E8%B7%AF%E7%B7%9A/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="示例图片"></p><h1 id="Java-Web-學習路線"><a href="#Java-Web-學習路線" class="headerlink" title="Java Web 學習路線"></a>Java Web 學習路線</h1><h2 id="1-Java-基礎知識"><a href="#1-Java-基礎知識" class="headerlink" title="1. Java 基礎知識"></a>1. Java 基礎知識</h2><ul><li><input disabled="" type="checkbox"> 確保對 Java 語言基本語法有足夠了解</li><li><input disabled="" type="checkbox"> 學習面向對象編程 (OOP) 的基本概念</li></ul><h2 id="2-Servlet-和-JSP"><a href="#2-Servlet-和-JSP" class="headerlink" title="2. Servlet 和 JSP"></a>2. Servlet 和 JSP</h2><ul><li><input disabled="" type="checkbox"> 了解 Servlet 的生命週期和基本用法</li><li><input disabled="" type="checkbox"> 理解 JSP 的基本語法和使用方式</li><li><input disabled="" type="checkbox"> 學習如何在 Servlet 中使用 JavaBean 和表單處理</li></ul><h2 id="3-Java-EE（現在稱為-Jakarta-EE）"><a href="#3-Java-EE（現在稱為-Jakarta-EE）" class="headerlink" title="3. Java EE（現在稱為 Jakarta EE）"></a>3. Java EE（現在稱為 Jakarta EE）</h2><ul><li><input disabled="" type="checkbox"> 瞭解 Java EE 的概念和組件（如 EJB、JMS 等）</li><li><input disabled="" type="checkbox"> 學習如何使用 Java Persistence API (JPA) 處理數據持久性</li><li><input disabled="" type="checkbox"> 掌握 JavaServer Faces (JSF) 框架</li></ul><h2 id="4-Spring-框架"><a href="#4-Spring-框架" class="headerlink" title="4. Spring 框架"></a>4. Spring 框架</h2><ul><li><input disabled="" type="checkbox"> 學習 Spring Framework 的基本概念和核心模組</li><li><input disabled="" type="checkbox"> 掌握 Spring MVC，用於構建 Web 應用程序</li><li><input disabled="" type="checkbox"> 學習 Spring Boot，加速應用程序的開發和部署</li></ul><h2 id="5-前端開發"><a href="#5-前端開發" class="headerlink" title="5. 前端開發"></a>5. 前端開發</h2><ul><li><input disabled="" type="checkbox"> 掌握 HTML、CSS 和 JavaScript 基礎知識</li><li><input disabled="" type="checkbox"> 學習一個前端框架，如 React、Angular 或 Vue.js</li><li><input disabled="" type="checkbox"> 瞭解前後端分離的概念和 RESTful API 的設計</li></ul><h2 id="6-數據庫"><a href="#6-數據庫" class="headerlink" title="6. 數據庫"></a>6. 數據庫</h2><ul><li><input disabled="" type="checkbox"> 熟悉關聯型數據庫，如 MySQL 或 Oracle</li><li><input disabled="" type="checkbox"> 學習使用 Hibernate 或 MyBatis 來實現對數據庫的訪問</li><li><input disabled="" type="checkbox"> 了解 NoSQL 數據庫的基本概念，如 MongoDB 或 Cassandra</li></ul><h2 id="7-安全性"><a href="#7-安全性" class="headerlink" title="7. 安全性"></a>7. 安全性</h2><ul><li><input disabled="" type="checkbox"> 學習如何防止常見的 Web 應用程序安全漏洞，如 SQL 注入和跨站腳本（XSS）</li><li><input disabled="" type="checkbox"> 瞭解身份驗證和授權的基本原則</li><li><input disabled="" type="checkbox"> 掌握 HTTPS 和加密技術</li></ul><h2 id="8-工具和開發流程"><a href="#8-工具和開發流程" class="headerlink" title="8. 工具和開發流程"></a>8. 工具和開發流程</h2><ul><li><input disabled="" type="checkbox"> 使用版本控制工具，如 Git</li><li><input disabled="" type="checkbox"> 學習使用 Maven 或 Gradle 進行項目建構</li><li><input disabled="" type="checkbox"> 瞭解持續集成和持續交付（CI&#x2F;CD）的基本概念</li></ul><h2 id="9-部署和監控"><a href="#9-部署和監控" class="headerlink" title="9. 部署和監控"></a>9. 部署和監控</h2><ul><li><input disabled="" type="checkbox"> 學習如何將應用程序部署到 Web 伺服器，如 Apache Tomcat 或 Jetty</li><li><input disabled="" type="checkbox"> 掌握應用程序監控和日誌記錄的基本方法</li><li><input disabled="" type="checkbox"> 了解容器化技術，如 Docker 和 Kubernetes</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Web Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> 學習路線 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试写博客的方法以及涵盖</title>
      <link href="/2023/11/15/%E5%B0%9D%E8%AF%95%E5%86%99blog%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%B6%B5%E7%9B%96%E7%9A%84%E5%86%85%E5%AE%B9/"/>
      <url>/2023/11/15/%E5%B0%9D%E8%AF%95%E5%86%99blog%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%B6%B5%E7%9B%96%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<!-- 将图片放在标题上方 --><p><img src="/images/lake.png" alt="示例图片"></p><h1 id="尝试写博客的方法以及涵盖"><a href="#尝试写博客的方法以及涵盖" class="headerlink" title="尝试写博客的方法以及涵盖"></a>尝试写博客的方法以及涵盖</h1><p>欢迎来到我的博客！写博客是分享知识、经验和思考的好方式。如果你正考虑尝试写博客，以下是一些建议和方法，以及你可以覆盖的一些主题。</p><h2 id="为什么写博客？"><a href="#为什么写博客？" class="headerlink" title="为什么写博客？"></a>为什么写博客？</h2><p><img src="/images/tree.png" alt="示例图片"><br>写博客有很多好处，包括但不限于：</p><ol><li><p><strong>分享知识和经验：</strong> 将你的学习和工作经验分享给他人，帮助他们解决问题或获取新的见解。</p></li><li><p><strong>建立个人品牌：</strong> 博客是展示你专业知识和兴趣的一个平台，有助于建立个人品牌。</p></li><li><p><strong>提高写作能力：</strong> 持续写作有助于提高表达和沟通能力。</p></li><li><p><strong>记录学习过程：</strong> 记录你的学习过程，方便日后回顾和总结。</p></li></ol><h2 id="如何开始写博客？"><a href="#如何开始写博客？" class="headerlink" title="如何开始写博客？"></a>如何开始写博客？</h2><h3 id="1-选择博客平台"><a href="#1-选择博客平台" class="headerlink" title="1. 选择博客平台"></a>1. 选择博客平台</h3><p>选择一个适合你的博客平台。常见的博客平台包括：</p><ul><li><a href="https://hexo.io/">Hexo</a></li><li><a href="https://jekyllrb.com/">Jekyll</a></li><li><a href="https://wordpress.org/">WordPress</a></li></ul><p>More info: <a href="https://blog.csdn.net/qq_58608526/article/details/124652412">Writing</a></p><h3 id="2-创建博客"><a href="#2-创建博客" class="headerlink" title="2. 创建博客"></a>2. 创建博客</h3><p>使用选定的博客平台创建你的博客。在 Hexo 中，你可以运行以下命令创建新博客：</p><pre><code class="bash">hexo new &quot;My First Blog&quot;</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
